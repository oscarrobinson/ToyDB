package toydb

import (
	"bytes"
	"errors"
	"reflect"
	"testing"
	"io"
)

func Test_parseOffsetMap_returnsCorrectMapWhenOneKey(t *testing.T) {
	// sha256("testkey"): 123
	fileContents := [48]byte{
		0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09}

	expectedKey := [32]byte{
		0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6}

	var expectedValue dataInfo = dataInfo{123, 9}

	expectedMap := map[[32]byte]dataInfo{expectedKey: expectedValue}

	offsetMap := parseOffsetMap(bytes.NewReader(fileContents[:]))

	if !reflect.DeepEqual(expectedMap, offsetMap) {
		t.Errorf("%d did not equal expected %d", offsetMap, expectedMap)
	}
}

func Test_parseOffsetMap_returnsCorrectMapWhenTwoKeys(t *testing.T) {
	// sha256("testkey"): 123
	fileContents := [96]byte{
		0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
		0x17, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6,
		0x00, 0x00, 0x02, 0x22, 0xE1, 0x59, 0xE7, 0xB2,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F}

	expectedKey := [32]byte{
		0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6}

	expectedKey2 := [32]byte{
		0x17, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6}

	var expectedValue dataInfo = dataInfo{123, 9}
	var expectedValue2 dataInfo = dataInfo{2348832909234, 15}

	expectedMap := map[[32]byte]dataInfo{expectedKey: expectedValue, expectedKey2: expectedValue2}

	offsetMap := parseOffsetMap(bytes.NewReader(fileContents[:]))

	if !reflect.DeepEqual(expectedMap, offsetMap) {
		t.Errorf("%d did not equal expected %d", offsetMap, expectedMap)
	}
}

func Test_parseOffsetMap_returnsMapWithLastValueWhenDuplicateKeys(t *testing.T) {
	// sha256("testkey"): 123
	fileContents := [96]byte{
		0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
		0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6,
		0x00, 0x00, 0x02, 0x22, 0xE1, 0x59, 0xE7, 0xB2,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F}

	expectedKey := [32]byte{
		0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3,
		0x2C, 0xBA, 0xE1, 0xA9, 0xCC, 0x2C, 0x65, 0xDA,
		0x3E, 0x3D, 0xD4, 0x58, 0xCF, 0x14, 0x04, 0xE1,
		0xFB, 0xC6, 0xCD, 0x29, 0x75, 0x95, 0x37, 0xE6}

	var expectedValue dataInfo = dataInfo{2348832909234, 15}

	expectedMap := map[[32]byte]dataInfo{expectedKey: expectedValue}

	offsetMap := parseOffsetMap(bytes.NewReader(fileContents[:]))

	if !reflect.DeepEqual(expectedMap, offsetMap) {
		t.Errorf("%d did not equal expected %d", offsetMap, expectedMap)
	}
}

func Test_writeData_writesAndReturnsBytesWrittenCount(t *testing.T) {
	var buffer bytes.Buffer
	dataToWrite := [8]byte{0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3}
	bytesWritten, err := writeData("RQ-1", &buffer, dataToWrite[:])

	if err != nil {
		t.Errorf("err: %d did not equal expected nil", err)
	}

	if bytesWritten != 8 {
		t.Errorf("bytesWritten: %d did not equal expected %d", bytesWritten, 8)
	}

	if !reflect.DeepEqual(buffer.Bytes(), dataToWrite[:]) {
		t.Errorf("%d %d did not equal expected %d %d", buffer.Bytes(), len(buffer.Bytes()), dataToWrite[:], len(dataToWrite[:]))
	}
}

type writerStub struct {
}

func (c writerStub) Write(data []byte) (int, error) {
	return 0, errors.New("Broken")
}

func Test_writeData_returnErrorWhenWriteErrors(t *testing.T) {
	writer := writerStub{}

	dataToWrite := [8]byte{0x07, 0x7F, 0x33, 0x77, 0xC2, 0xE9, 0xAE, 0xD3}
	bytesWritten, err := writeData("RQ-1", &writer, dataToWrite[:])

	if err.Error() != "Broken" {
		t.Errorf("err: %s did not equal expected %s", err.Error(), "Broken")
	}

	if bytesWritten != 0 {
		t.Errorf("bytesWritten: %d did not equal expected %d", bytesWritten, 0)
	}
}

type mockEngineReadFile struct {
	io.ReaderAt
}

func (mockEngineReadFile) Close() error { return nil }
func (mockEngineReadFile) Write(p []byte) (int, error) { return 0, nil}

func Test_StorageEngine_Get_returnsValueForKey(t *testing.T) {
	dataFileContents := [48]byte{
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10}

	sha256Key := [32]byte{
		0x52, 0xec, 0x14, 0x80, 0x30, 0x8a, 0x78, 0xb9, 
		0xf1, 0xc9, 0xc7, 0xd9, 0x65, 0x4d, 0x4a, 0x85, 
		0x81, 0x9c, 0x26, 0xb3, 0x3a, 0x32, 0xf5, 0xc2, 
		0x7d, 0x47, 0x2a, 0x46, 0x2f, 0x10, 0x2f, 0x45}

	storageEngine := new(StorageEngine)
	fakeDataFile := bytes.NewReader(dataFileContents[:])
	storageEngine.dataFile = mockEngineReadFile{fakeDataFile}
	storageEngine.offsetMap = make(map[[32]byte]dataInfo)
	storageEngine.offsetMap[sha256Key] = dataInfo{3, 5}

	result, _ := storageEngine.Get("randomkey")

	expectedResult := [5]byte{0x04, 0x05, 0x06, 0x07, 0x08}

	if !reflect.DeepEqual(result, expectedResult[:]) {
		t.Errorf("%d did not equal expected %d", result, expectedResult[:])
	}
}

//TODO - Tests for failure cases
